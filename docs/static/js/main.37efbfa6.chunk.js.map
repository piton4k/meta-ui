{"version":3,"sources":["app/App.module.styl","app/Card.module.styl","app/Column.module.styl","app/Tabs.module.styl","form/Form.tsx","meta/Schema.ts","form/Control.tsx","form/Field.tsx","form/TextInput.tsx","form/Toggle.tsx","meta/Cursor.ts","meta/SchemaRenderer.tsx","util/IdGenerator.ts","validated/Validated.ts","util/validations.ts","meta/SchemaValidator.ts","app/Card.tsx","app/Code.tsx","app/Json.tsx","app/Demo.tsx","meta/metaSchema.ts","util/index.ts","util/storage.tsx","app/Column.tsx","app/Meta.tsx","app/Tabs.tsx","app/App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","Form","children","rest","unit","value","undefined","type","boolean","string","record","fields","Object","entries","map","name","schema","variant","cases","sequence","Control","className","classNames","Field","errors","hasErrors","length","error","i","TextInput","onChange","restProps","e","target","Toggle","values","allowEmpty","onClick","v","makeKey","path","join","extend","segments","Cursor","key","this","FormState","state","setState","cursor","mutate","set","newState","setMany","remove","removeAll","update","f","modify","result","mutations","keys","k","startsWith","idGen","current","next","makeIdGenerator","renderSchema","formState","render","get","there","down","typeCursor","innerSchema","find","idsCursor","ids","rem","id","filter","getSchema","valid","invalid","combineArray","left","right","combineObject","defaultCombineError","traverse","combine","push","reduce","expected","what","input","Validated","validate","decode","onError","validations","fromEntries","types","decoder","Card","expandable","title","useState","isExpanded","setIsExpanded","classes","style","card","isExpandable","body","Code","code","Json","indent","JSON","stringify","demoSchema","Schema","fruit","contact","Address","city","street","country","Phone","games","consent","metaSchema","fix","self","Unit","Boolean","Enumeration","String","Record","Variant","Sequence","whenDefined","getDefault","def","createUseStorage","storage","load","item","window","localStorage","getItem","parse","console","loadOrElse","save","setItem","loadOrCreate","removeItem","defaultValue","setValue","useEffect","Column","column","Columns","columns","useStorage","Tabs","tabs","selectedTab","setSelectedTab","header","Demo","validatedData","Meta","state1","setState1","formState1","validatedData1","isValid","isInvalid","errors1","methods","method","setMethod","url","setUrl","form","fetch","then","r","json","log","catch","warn","disabled","App","app","main","page","tab","Tab","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.37efbfa6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__19O7e\",\"header\":\"App_header__aow5j\",\"main\":\"App_main__2uj_m\",\"page\":\"App_page__38t76\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"card\":\"Card_card__fWgo5\",\"isExpandable\":\"Card_is-expandable__ATcee\",\"body\":\"Card_body__3yUc7\",\"isExpanded\":\"Card_is-expanded__pUvNj\",\"title\":\"Card_title__DWLMt\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"columns\":\"Column_columns__2L1jO\",\"column\":\"Column_column__2ykxZ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Tabs_header__xydOr\"};","import React from \"react\"\n\ntype Props = {\n  children?: React.ReactNode\n}\n\nexport default function Form({ children, ...rest }: Props) {\n  return <form {...rest}>\n    {children}\n  </form>\n}\n","export type Schema =\n  Unit |\n  Boolean |\n  Enumeration |\n  String |\n  Record |\n  Variant |\n  Sequence |\n  Lazy\n\ntype Unit<A = any> = {\n  type: \"Unit\"\n  value: A\n}\n\ntype Boolean = {\n  type: \"Boolean\"\n}\n\ntype Enumeration = {\n  type: \"Enumeration\"\n  values: string[]\n}\n\ntype String = {\n  type: \"String\"\n}\n\ntype Record = {\n  type: \"Record\"\n  fields: Field[]\n}\n\ntype Field = {\n  name: string\n  schema: Schema\n}\n\ntype Variant = {\n  type: \"Variant\"\n  cases: Case[]\n}\n\ntype Case = {\n  name: string\n  schema: Schema\n}\n\ntype Sequence = {\n  type: \"Sequence\"\n  schema: Schema\n}\n\ntype Lazy = {\n  type: \"Lazy\"\n  getSchema: () => Schema\n}\n\nexport function unit<A = any>(value: A = undefined as unknown as A): Unit<A> {\n  return {\n    type: \"Unit\",\n    value,\n  }\n}\n\nexport const boolean: Boolean = {\n  type: \"Boolean\",\n}\n\nexport function enumeration(values: string[]): Enumeration {\n  return {\n    type: \"Enumeration\",\n    values,\n  }\n}\n\nexport const string: String = {\n  type: \"String\",\n}\n\nexport function record(fields: { [key: string]: Schema }): Record {\n  return {\n    type: \"Record\",\n    fields: Object.entries(fields).map(([name, schema]) => ({ name, schema })),\n  }\n}\n\nexport function variant(cases: { [key: string]: Schema }): Variant {\n  return {\n    type: \"Variant\",\n    cases: Object.entries(cases).map(([name, schema]) => ({ name, schema })),\n  }\n}\n\nexport function sequence(schema: Schema): Sequence {\n  return {\n    type: \"Sequence\",\n    schema,\n  }\n}\n\nexport function lazy(getSchema: () => Schema): Lazy {\n  return {\n    type: \"Lazy\",\n    getSchema,\n  }\n}\n\nexport function fix(f: (self: Schema) => Schema): Schema {\n  return f(lazy(() => fix(f)))\n}\n","import classNames from \"classnames\"\nimport React from \"react\"\nimport \"./Control.styl\"\n\ntype Props = {\n  className?: string\n  children?: React.ReactNode\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport default function Control({ className, children, ...rest }: Props) {\n  return <div className={classNames(\"control\", className)} {...rest}>\n    {children}\n  </div>\n}\n","import classNames from \"classnames\"\nimport React from \"react\"\nimport Control from \"./Control\"\n\ntype Props = {\n  errors?: string[]\n  children?: React.ReactNode\n}\n\nexport default function Field({ errors, children }: Props) {\n  const hasErrors = errors != null && errors.length !== 0\n\n  return <Control className={classNames({ \"is-danger\": hasErrors })}>\n    {children}\n    {hasErrors && <ul className=\"messages\">\n      {errors && errors.map((error, i) => <li key={i}>{error}</li>)}\n    </ul>}\n  </Control>\n}\n","import React from \"react\"\nimport \"./TextInput.styl\"\n\ntype Props = {\n  value?: string\n  onChange?: (value: string) => void\n} & Omit<React.HTMLAttributes<HTMLInputElement>, \"onChange\">\n\nexport default function TextInput({ value, onChange = () => {}, ...restProps }: Props) {\n  return <div>\n    <input\n      type=\"text\"\n      className=\"text-input\"\n      value={value}\n      onChange={e => onChange(e.target.value)}\n      {...restProps}\n    />\n  </div>\n}\n","import classNames from \"classnames\"\nimport \"./Toggle.styl\"\n\ntype Value = string\n\ntype Props = {\n  values: Value[]\n  value?: Value\n  onChange?: (value: Value | undefined) => void\n  allowEmpty?: boolean\n}\n\nexport default function Toggle({ values, value, onChange = () => {}, allowEmpty = false }: Props) {\n  const onClick = (v: Value) => () => {\n    if (v === value) {\n      if (allowEmpty) onChange(undefined)\n    }\n    else onChange(v)\n  }\n\n  return <div className=\"toggle-group\">\n    {values.map(v => <span\n      key={v}\n      className={classNames(\"toggle\", { \"is-toggled\": v === value})}\n      onClick={onClick(v)}\n    >{v}</span>)}\n  </div>\n}\n","export type PathSegment = string | number\r\nexport type Path = PathSegment[]\r\n\r\nexport function makeKey(path: Path): string {\r\n  return path.join(\".\")\r\n}\r\n\r\nexport function extend(path: Path, ...segments: Path): Path {\r\n  return segments.length === 0 ? path : [...path, ...segments]\r\n}\r\n\r\nexport default class Cursor {\r\n  readonly path: Path\r\n  readonly key: string\r\n\r\n  constructor(path: Path = []) {\r\n    this.path = path\r\n    this.key = makeKey(path)\r\n  }\r\n\r\n  down(...segments: Path): Cursor {\r\n    return new Cursor(extend(this.path, ...segments))\r\n  }\r\n}\r\n","import React from \"react\"\nimport Field from \"../form/Field\"\nimport TextInput from \"../form/TextInput\"\nimport Toggle from \"../form/Toggle\"\nimport { makeIdGenerator } from \"../util/IdGenerator\"\nimport Cursor from \"./Cursor\"\nimport * as Schema from \"./Schema\"\n\nexport type State<A = any> = {\n  [key: string]: A\n}\n\nexport type SetState<A = any> = (state: State<A>) => void\n\ntype Endo<A> = (value: A) => A\n\nexport class FormState {\n  private readonly state: State\n  private readonly setState: SetState\n\n  constructor(state: State, setState: SetState) {\n    this.state = state\n    this.setState = setState\n  }\n\n  get<A = string>(cursor: Cursor): A | undefined {\n    return this.state[cursor.key] as A | undefined\n  }\n\n  set<A>(cursor: Cursor, value: A): void {\n    this.mutate(FormState.set(cursor, value))\n  }\n\n  setMany(newState: State): void {\n    this.mutate(FormState.setMany(newState))\n  }\n\n  remove(cursor: Cursor): void {\n    this.mutate(FormState.remove(cursor))\n  }\n\n  removeAll(cursor: Cursor): void {\n    this.mutate(FormState.removeAll(cursor))\n  }\n\n  update<A>(cursor: Cursor, value: A | undefined): void {\n    this.mutate(FormState.update(cursor, value))\n  }\n\n  modify<A>(cursor: Cursor, f: (value: A | undefined) => A | undefined): void {\n    this.mutate(FormState.modify(cursor, f))\n  }\n\n  mutate(...mutations: Endo<State>[]): void {\n    let result = this.state\n    for (const f of mutations) {\n      result = f(result)\n    }\n    this.setState(result)\n  }\n\n  static set<A>(cursor: Cursor, value: A): Endo<State> {\n    return FormState.modify<A>(cursor, () => value)\n  }\n\n  static setMany(newState: State): Endo<State> {\n    return state => ({ ...state, ...newState })\n  }\n\n  static remove(cursor: Cursor): Endo<State> {\n    return FormState.modify(cursor, () => undefined)\n  }\n\n  static removeAll(cursor: Cursor): Endo<State> {\n    return state => {\n      const newState = { ...state }\n      for (const k of Object.keys(newState)) {\n        if (k.startsWith(cursor.key)) delete newState[k]\n      }\n      return newState\n    }\n  }\n\n  static update<A>(cursor: Cursor, value: A | undefined): Endo<State> {\n    return FormState.modify(cursor, () => value)\n  }\n\n  static modify<A>(cursor: Cursor, f: (value: A | undefined) => A | undefined): Endo<State> {\n    return state => {\n      const value = f(state[cursor.key] as A | undefined)\n      if (value != null) {\n        return { ...state, [cursor.key]: value }\n      }\n      else {\n        const { [cursor.key]: value, ...newState } = state\n        return newState\n      }\n    }\n  }\n}\n\nexport type Errors = State<string[]>\n\nconst idGen = makeIdGenerator()\n\nexport function renderSchema(schema: Schema.Schema, formState: FormState, errors: Errors = {}): React.ReactNode {\n  function render(schema: Schema.Schema, cursor: Cursor): JSX.Element | null {\n    const value = formState.get(cursor)\n    function update<A = any>(value: A) {\n      formState.update(cursor, value)\n    }\n\n    switch (schema.type) {\n      case \"Unit\":\n        return null\n      case \"Boolean\":\n        return <Field errors={errors[cursor.key]}>\n          <Toggle values={[\"True\", \"False\"]} value={value} onChange={update} allowEmpty/>\n        </Field>\n      case \"Enumeration\":\n        return <Field errors={errors[cursor.key]}>\n          <Toggle values={schema.values} value={value} onChange={update} allowEmpty/>\n        </Field>\n      case \"String\":\n        return <Field errors={errors[cursor.key]}>\n          <TextInput value={value ?? \"\"} onChange={update}/>\n        </Field>\n      case \"Record\":\n        return <div>\n          {schema.fields.map(({ name, schema }) => {\n            if (schema.type === \"Unit\") return null\n            const there = cursor.down(name)\n            return <div key={there.key}>\n              <div>{name}</div>\n              {render(schema, there)}\n            </div>\n          })}\n        </div>\n      case \"Variant\":\n        const typeCursor = cursor.down(\"type\")\n        const type = formState.get(typeCursor)\n        const innerSchema = schema.cases.find(({ name }) => name === type)?.schema\n\n        return <div>\n          <Toggle values={schema.cases.map(({ name }) => name)} value={type} onChange={value => formState.update(typeCursor, value)}/>\n          {type && innerSchema && render(innerSchema, cursor.down(type))}\n        </div>\n      case \"Sequence\":\n        const idsCursor = cursor.down(\"ids\")\n        const ids = formState.get<string[]>(idsCursor) ?? []\n        const add = () => formState.set(idsCursor, [...ids, idGen.next()])\n        const rem = (id: string) => () => {\n          formState.mutate(\n            FormState.set(idsCursor, ids.filter(i => i !== id)),\n            FormState.removeAll(cursor.down(id)),\n          )\n        }\n\n        return <div>\n          <button type=\"button\" onClick={add}>Add</button>\n          {ids.map(id => {\n            const there = cursor.down(id)\n            return <div key={there.key}>\n              <button type=\"button\" onClick={rem(id)}>Remove</button>\n              {render(schema.schema, there)}\n            </div>\n          })}\n        </div>\n      case \"Lazy\":\n        return render(schema.getSchema(), cursor)\n    }\n  }\n\n  return render(schema, new Cursor())\n}\n","export type IdGenerator = {\n  next: () => number\n}\n\nexport function makeIdGenerator(start: number = 0) {\n  let current = 0\n  const next = () => {\n    const result = current\n    current += 1\n    return result\n  }\n\n  return { next }\n}\n","export type Validated<E, A> =\n  Valid<A> |\n  Invalid<E>\n\nexport type Valid<A> = {\n  type: \"Valid\"\n  value: A\n}\n\nexport type Invalid<E> = {\n  type: \"Invalid\"\n  error: E\n}\n\nexport function valid<E, A>(value: A): Validated<E, A> {\n  return {\n    type: \"Valid\",\n    value,\n  }\n}\n\nexport function invalid<E, A>(error: E): Validated<E, A> {\n  return {\n    type: \"Invalid\",\n    error,\n  }\n}\n\nexport function pure<E, A>(value: A): Validated<E, A> {\n  return valid(value)\n}\n\nexport function map<E, A, B>(value: Validated<E, A>, f: (value: A) => B): Validated<E, B> {\n  switch (value.type) {\n    case \"Valid\":\n      return valid(f(value.value))\n    case \"Invalid\":\n      return value\n  }\n}\n\nexport function errorMap<E, A, F>(value: Validated<E, A>, f: (error: E) => F): Validated<F, A> {\n  switch (value.type) {\n    case \"Valid\":\n      return value\n    case \"Invalid\":\n      return invalid(f(value.error))\n  }\n}\n\nexport function andThen<E, A, B>(value: Validated<E, A>, f: (value: A) => Validated<E, B>): Validated<E, B> {\n  switch (value.type) {\n    case \"Valid\":\n      return f(value.value)\n    case \"Invalid\":\n      return value\n  }\n}\n\ntype Combine<C, A = C, B = C> = (left: A, right: B) => C\n\nexport function combine<E, A, B, C>(left: Validated<E, A>, right: Validated<E, B>, f: Combine<C, A, B>, g: Combine<E>): Validated<E, C> {\n  switch (left.type) {\n    case \"Valid\":\n      switch (right.type) {\n        case \"Valid\":\n          return valid(f(left.value, right.value))\n        case \"Invalid\":\n          return right\n      }\n      break // ???\n    case \"Invalid\":\n      switch (right.type) {\n        case \"Valid\":\n          return left\n        case \"Invalid\":\n          return invalid(g(left.error, right.error))\n      }\n  }\n}\n\nexport function combineArray<E>(left: E[], right: E[]): E[] {\n  return [...left, ...right]\n}\n\nexport function combineArrayToLeft<E>(left: E[], right: E[]): E[] {\n  return left.concat(...right)\n}\n\nexport function combineObject<A>(left: { [key: string]: A }, right: { [key: string]: A }): { [key: string]: A } {\n  return { ...left, ...right }\n}\n\nexport function defaultCombineError<E>(): Combine<E> {\n  // this isn't sound but it's a default for when E = A[]\n  return combineArray as unknown as Combine<E>\n}\n\nexport function traverse<E, A, B>(values: A[], f: (value: A) => Validated<E, B>, combine: Combine<E> = defaultCombineError<E>()): Validated<E, B[]> {\n  const result = []\n  const errors = []\n\n  for (const value of values) {\n    const v = f(value)\n    switch (v.type) {\n      case \"Valid\":\n        result.push(v.value)\n        break\n      case \"Invalid\":\n        errors.push(v.error)\n        break\n    }\n  }\n\n  return errors.length === 0\n    ? valid(result)\n    : invalid(errors.reduce(combine))\n}\n\nexport function sequence<E, A>(values: Validated<E, A>[], combine: Combine<E> = defaultCombineError<E>()): Validated<E, A[]> {\n  return traverse(values, x => x, combine)\n}\n","import * as Validated from \"../validated/Validated\"\n\ntype StringValidated<A> = Validated.Validated<string[], A>\n\nexport type StringDecoder<A> = (input: string) => StringValidated<A>\ntype StringEncoder<A> = (value: A) => string\n\ntype ErrorFormat = (input: string) => string\n\nconst just = (error: string): ErrorFormat => () => error\nconst expected = (what: string): ErrorFormat => input => `Expected ${what}, got: \"${input}\"`\n\nfunction valid<A>(value: A): StringValidated<A> {\n  return Validated.valid(value)\n}\n\nfunction invalid(error: string): Validated.Validated<string[], any> {\n  return Validated.invalid([error])\n}\n\nexport function nonEmpty(onError: ErrorFormat = just(\"Input is empty\")): StringDecoder<string> {\n  return input => input.length === 0\n    ? Validated.invalid([onError(input)])\n    : Validated.valid(input)\n}\n\nconst defaultMessage = (input: string, e: Error) => e?.message ?? `${e}`\n\nexport function attempt<A>(f: (input: string) => A, message: (input: string, e: Error) => string = defaultMessage): StringDecoder<A> {\n  return input => {\n    try {\n      return valid(f(input))\n    } catch (e) {\n      return invalid(message(input, e))\n    }\n  }\n}\n\nexport function boolean(onError: ErrorFormat = expected(\"boolean\")): StringDecoder<boolean> {\n  return input => {\n    switch (input) {\n      case \"True\":\n        return valid(true)\n      case \"False\":\n        return valid(false)\n      default:\n        return invalid(onError(input))\n    }\n  }\n}\n\nexport function float(onError: ErrorFormat = expected(\"float\")): StringDecoder<number> {\n  return attempt(parseFloat, onError)\n}\n\nexport function int(onError: ErrorFormat = expected(\"integer\")): StringDecoder<number> {\n  return attempt(parseInt, onError)\n}\n\nexport function json<A>(onError: ErrorFormat = expected(\"json\")): StringDecoder<A> {\n  return attempt(input => JSON.parse(input) as A, onError)\n}\n\nexport function enumeration(values: string[], onError: ErrorFormat = expected(`one of [${values.join(\", \")}]`)): StringDecoder<string> {\n  return input => {\n    const value = values.find(e => e === input)\n    return value != null\n      ? valid(value)\n      : invalid(onError(input))\n  }\n}\n\nexport function required<A>(decoder: StringDecoder<A | undefined>): StringDecoder<A> {\n  return input => {\n    const result = decoder(input)\n    return result != null\n      ? valid(result)\n      : invalid(\"Value is missing\")\n  }\n}\n\nexport function optional<A>(decoder: StringDecoder<A>): StringDecoder<A | undefined> {\n  return input => {\n    const result = decoder(input)\n    switch (result.type) {\n      case \"Valid\":\n        return result\n      case \"Invalid\":\n        return valid(undefined)\n    }\n  }\n}\n\nexport type StringFormat<A> = {\n  decode: StringDecoder<A>\n  encode: StringEncoder<A>\n}\n\nexport function stringFormat<A>(decode: StringDecoder<A>, encode: StringEncoder<A> = value => `${value}`): StringFormat<A> {\n  return { decode, encode }\n}\n\nexport function nonEmptyFormat(onError: ErrorFormat = just(\"Input is empty\")): StringFormat<string> {\n  return stringFormat(nonEmpty(onError), value => value)\n}\n\nexport function floatFormat(onError: ErrorFormat = expected(\"float\")): StringFormat<number> {\n  return stringFormat(float(onError))\n}\n\nexport function intFormat(onError: ErrorFormat = expected(\"integer\")): StringFormat<number> {\n  return stringFormat(int(onError))\n}\n\nexport function jsonFormat<A>(indent: number = 2, onError: ErrorFormat = expected(\"json\")): StringFormat<A> {\n  return stringFormat(json(onError), value => JSON.stringify(value, null, indent))\n}\n","import * as validations from \"../util/validations\"\nimport { StringDecoder } from \"../util/validations\"\nimport * as Validated from \"../validated/Validated\"\nimport Cursor from \"./Cursor\"\nimport * as Schema from \"./Schema\"\nimport { Errors, State } from \"./SchemaRenderer\"\n\nexport function validate<A = any>(schema: Schema.Schema, state: State): Validated.Validated<Errors, A> {\n  function validate(schema: Schema.Schema, cursor: Cursor): Validated.Validated<Errors, any> {\n    switch (schema.type) {\n      case \"Unit\":\n        return Validated.valid(schema.value)\n      case \"Boolean\":\n        return decode(cursor, state, validations.boolean())\n      case \"Enumeration\":\n        return decode(cursor, state, validations.enumeration(schema.values))\n      case \"String\":\n        return decode(cursor, state, Validated.valid)\n      case \"Record\":\n        return Validated.map(\n          Validated.traverse(\n            schema.fields,\n            ({ name, schema }) => Validated.map(\n              validate(schema, cursor.down(name)),\n              value => [name, value],\n            ),\n            Validated.combineObject,\n          ),\n          Object.fromEntries,\n        )\n      case \"Variant\":\n        const type = get(cursor.down(\"type\"), state)\n        if (type == null) return invalid(cursor, \"Type is missing\")\n\n        const innerSchema = schema.cases.find(({ name }) => name === type)?.schema\n        if (innerSchema == null) {\n          const types = schema.cases.map(({ name }) => name)\n          return invalid(cursor, `Invalid type \"${type}\", expected one of [${types.join(\", \")}]`)\n        }\n\n        return validate(innerSchema, cursor.down(type))\n      case \"Sequence\":\n        const ids = get<string[]>(cursor.down(\"ids\"), state) ?? []\n        return Validated.traverse(\n          ids,\n          id => validate(schema.schema, cursor.down(id)),\n          Validated.combineObject,\n        )\n      case \"Lazy\":\n        return validate(schema.getSchema(), cursor)\n      default:\n        return invalid(cursor, `Invalid schema \"${schema}\"`)\n    }\n  }\n\n  return validate(schema, new Cursor()) as Validated.Validated<Errors, A>\n}\n\nfunction get<A = string>(cursor: Cursor, state: State): A | undefined {\n  return state[cursor.key] as A\n}\n\nfunction invalid<A>(cursor: Cursor, ...errors: string[]): Validated.Validated<Errors, A> {\n  return Validated.invalid({ [cursor.key]: errors })\n}\n\nfunction decode<A>(cursor: Cursor, state: State, decoder: StringDecoder<A>): Validated.Validated<Errors, A> {\n  const value = get(cursor, state)\n  const validated = value != null\n    ? decoder(value)\n    : Validated.invalid<string[], A>([\"Value is missing\"])\n  return Validated.errorMap(validated, errors => ({ [cursor.key]: errors }))\n}\n\n// export function loadState<A = any>(schema: Schema.Schema, value: A): State {\n//   const result = {}\n//\n//   function load(cursor: Cursor): void {\n//     switch (schema.type) {\n//       case \"Unit\":\n//         return {}\n//       case \"Boolean\":\n//         return {}\n//       case \"Enumeration\":\n//         break\n//       case \"String\":\n//         break\n//       case \"Record\":\n//         break\n//       case \"Variant\":\n//         break\n//       case \"Sequence\":\n//         break\n//       case \"Lazy\":\n//         break\n//     }\n//   }\n//\n//   load(new Cursor())\n//\n//   return result\n// }\n","import classNames from \"classnames\"\nimport React, { useState } from \"react\"\nimport style from \"./Card.module.styl\"\n\ntype Props = {\n  className?: string\n  expandable?: true\n  title?: string,\n  children?: React.ReactNode\n}\n\nexport default function Card({ className, expandable, title, children, ...rest }: Props) {\n  const [isExpanded, setIsExpanded] = useState(false)\n  const classes = classNames(style.card, className, expandable && style.isExpandable, { [style.isExpanded]: isExpanded })\n\n  return <div className={classes} {...rest}>\n    {title && <div className={style.title}>{title}</div>}\n\n    <div className={style.body}>\n      {expandable && <button\n        type=\"button\"\n        onClick={() => setIsExpanded(!isExpanded)}\n      >{isExpanded ? \"Show less\" : \"Show more\"}</button>}\n\n      {children}\n    </div>\n  </div>\n}\n","import React from \"react\"\nimport style from \"./Code.module.styl\"\n\ntype Props = {\n  children?: React.ReactNode\n}\n\nexport default function Code({ children }: Props) {\n  return <pre className={style.code}>\n    <code>\n      {children}\n    </code>\n  </pre>\n}\n","import React from \"react\"\nimport Code from \"./Code\"\n\ntype Props = {\n  indent?: number\n  children?: React.ReactNode\n}\n\nexport default function Json({ children, indent = 4 }: Props) {\n  return <Code>{JSON.stringify(children, null, indent)}</Code>\n}\n","import React, { useState } from \"react\"\nimport Form from \"../form/Form\"\nimport * as Schema from \"../meta/Schema\"\nimport { FormState, renderSchema, State } from \"../meta/SchemaRenderer\"\nimport { validate } from \"../meta/SchemaValidator\"\nimport Card from \"./Card\"\nimport Json from \"./Json\"\n\nexport default function Demo() {\n  const schema = demoSchema\n  const [state, setState] = useState<State>({})\n  const formState = new FormState(state, setState)\n  const validatedData = validate(schema, state)\n  const errors = validatedData.type === \"Invalid\" ? validatedData.error : undefined\n\n  return <>\n    <Card expandable title=\"Schema\">\n      <Json>{schema}</Json>\n    </Card>\n\n    <Card title=\"Form\">\n      <Form>\n        {renderSchema(schema, formState, errors)}\n      </Form>\n    </Card>\n\n    <Card title=\"State\">\n      <Json>{state}</Json>\n    </Card>\n\n    <Card title=\"Result\">\n      <Json>{validatedData}</Json>\n    </Card>\n  </>\n}\n\nconst fruits = [\"Apples\", \"Bananas\", \"Oranges\"]\nconst demoSchema: Schema.Schema = Schema.record({\n  name: Schema.string,\n  fruit: Schema.enumeration(fruits),\n  contact: Schema.variant({\n    Address: Schema.record({\n      city: Schema.string,\n      street: Schema.string,\n      country: Schema.string,\n    }),\n    Phone: Schema.string,\n  }),\n  games: Schema.sequence(\n    Schema.string,\n  ),\n  consent: Schema.boolean,\n})\n","import * as Schema from \"./Schema\"\r\n\r\nexport const metaSchema = Schema.fix(self => Schema.variant({\r\n  Unit: Schema.unit(Schema.unit()),\r\n  Boolean: Schema.unit(Schema.boolean),\r\n  Enumeration: Schema.record({\r\n    type: Schema.unit(\"Enumeration\"),\r\n    values: Schema.sequence(Schema.string),\r\n  }),\r\n  String: Schema.unit(Schema.string),\r\n  Record: Schema.record({\r\n    type: Schema.unit(\"Record\"),\r\n    fields: Schema.sequence(Schema.record({\r\n      name: Schema.string,\r\n      schema: self,\r\n    })),\r\n  }),\r\n  Variant: Schema.record({\r\n    type: Schema.unit(\"Variant\"),\r\n    cases: Schema.sequence(Schema.record({\r\n      name: Schema.string,\r\n      schema: self,\r\n    })),\r\n  }),\r\n  Sequence: Schema.record({\r\n    type: Schema.unit(\"Sequence\"),\r\n    schema: self,\r\n  }),\r\n}))\r\n","export function whenDefined<A>(f: (value: A) => void): (value: A | undefined) => void {\n  return value => {\n    if (value != null) f(value)\n  }\n}\n","import { useEffect, useState } from \"react\"\n\ntype LocalStorage<A> = {\n  load: () => A | null\n  loadOrElse: (f: Default<A>) => A\n  loadOrCreate: (f: Default<A>) => A\n  save: (value: A) => void\n  remove: () => void\n}\n\ntype Default<A> = A | (() => A)\n\nfunction getDefault<A>(def: Default<A>): A {\n  return typeof def === \"function\"\n    ? (def as () => A)()\n    : def\n}\n\nexport function localStorage<A>(key: string): LocalStorage<A> {\n  function load(): A | null {\n    const item = window.localStorage.getItem(key)\n    if (item != null) {\n      try {\n        return JSON.parse(item)\n      }\n      catch (e) {\n        console.error(`Error while loading ${key} -`, e)\n      }\n    }\n    return null\n  }\n\n  function loadOrElse(f: Default<A>): A {\n    return load() ?? getDefault(f)\n  }\n\n  function save(value: A): void {\n    window.localStorage.setItem(key, JSON.stringify(value))\n  }\n\n  function loadOrCreate(f: Default<A>): A {\n    return loadOrElse(() => {\n      const result = getDefault(f)\n      save(result)\n      return result\n    })\n  }\n\n  function remove(): void {\n    window.localStorage.removeItem(key)\n  }\n\n  return {\n    load,\n    loadOrElse,\n    loadOrCreate,\n    save,\n    remove,\n  }\n}\n\ntype UseStorage<A> = (value: Default<A>) => [A, (value: A) => void]\n\nexport function createUseStorage<A>(key: string): [LocalStorage<A>, UseStorage<A>] {\n  const storage = localStorage<A>(key)\n\n  function useStorage(defaultValue: Default<A>): ReturnType<UseStorage<A>> {\n    const [value, setValue] = useState<A>(() => storage.load() ?? getDefault(defaultValue))\n    useEffect(() => storage.save(value), [value])\n    return [value, setValue]\n  }\n\n  return [storage, useStorage]\n}\n","import React from \"react\"\r\nimport style from \"./Column.module.styl\"\r\n\r\ntype Props = {\r\n  children?: React.ReactNode\r\n}\r\n\r\nexport function Column({ children }: Props) {\r\n  return <div className={style.column}>\r\n    {children}\r\n  </div>\r\n}\r\n\r\nexport function Columns({ children }: Props) {\r\n  return <div className={style.columns}>\r\n    {children}\r\n  </div>\r\n}\r\n","import { useEffect, useState } from \"react\"\nimport Form from \"../form/Form\"\nimport Toggle from \"../form/Toggle\"\nimport { metaSchema } from \"../meta/metaSchema\"\nimport * as Schema from \"../meta/Schema\"\nimport { FormState, renderSchema, State } from \"../meta/SchemaRenderer\"\nimport { validate } from \"../meta/SchemaValidator\"\nimport { whenDefined } from \"../util\"\nimport { createUseStorage } from \"../util/storage\"\nimport * as Validated from \"../validated/Validated\"\nimport style from \"./App.module.styl\"\nimport Card from \"./Card\"\nimport { Column, Columns } from \"./Column\"\nimport Json from \"./Json\"\n\nexport const [storage] = createUseStorage<Schema.Schema>(\"schema\")\n\nexport default function Meta() {\n  const [state, setState] = useState<State>(storage.loadOrElse(Schema.unit))\n  const formState = new FormState(state, setState)\n\n  const validatedData = validate<Schema.Schema>(metaSchema, state)\n  const schema = validatedData.type === \"Valid\" ? validatedData.value : undefined\n  const errors = validatedData.type === \"Invalid\" ? validatedData.error : undefined\n\n  const [state1, setState1] = useState<State>({})\n  const formState1 = new FormState(state1, setState1)\n\n  const validatedData1 = Validated.andThen(validatedData, schema => validate(schema, state1))\n  const isValid = validatedData1.type === \"Valid\"\n  const isInvalid = validatedData1.type === \"Invalid\"\n  const value = validatedData1.type === \"Valid\" ? validatedData1.value : undefined\n  const errors1 = validatedData1.type === \"Invalid\" ? validatedData1.error : undefined\n\n  useEffect(() => {\n    if (schema != null) storage.save(schema)\n  }, [schema])\n\n  const methods = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n  const [method, setMethod] = useState(methods[1])\n  const [url, setUrl] = useState(\"//localhost:8080\")\n  const onSubmit = () => {\n    if (isValid) {\n      fetch(url, { method: \"POST\", body: JSON.stringify(value) })\n        .then(r => r.json())\n        .then(console.log)\n        .catch(console.warn)\n    }\n  }\n\n  return <Columns>\n    <Column>\n      <Card className={style.form} title=\"Schema\">\n        <Form>\n          {renderSchema(metaSchema, formState, errors)}\n        </Form>\n\n        <h2>State</h2>\n        <Json>{state}</Json>\n\n        <h2>Result</h2>\n        <Json>{validatedData}</Json>\n      </Card>\n    </Column>\n\n    {schema && <Column>\n      <Card title=\"Form\">\n        <Form>\n          {renderSchema(schema, formState1, errors1)}\n        </Form>\n\n        <h2>State</h2>\n        <Json>{state1}</Json>\n\n        <h2>Result</h2>\n        <Json>{validatedData1}</Json>\n\n        <h2>Request</h2>\n        <Toggle values={methods} value={method} onChange={whenDefined(setMethod)}/>\n        <input type=\"string\" value={url} onChange={e => setUrl(e.target.value)}/>\n        <button type=\"button\" onClick={onSubmit} disabled={isInvalid}>Submit</button>\n      </Card>\n    </Column>}\n  </Columns>\n}\n","import React from \"react\"\nimport Toggle from \"../form/Toggle\"\nimport { whenDefined } from \"../util\"\nimport { createUseStorage } from \"../util/storage\"\nimport style from \"./Tabs.module.styl\"\n\ntype Props = {\n  tabs: string[]\n  render: (tab: string) => React.ReactNode\n}\n\nconst [, useStorage] = createUseStorage<string>(\"currentTab\")\n\nexport default function Tabs({ tabs, render }: Props) {\n  const [selectedTab, setSelectedTab] = useStorage(tabs[0])\n\n  return <>\n    <div className={style.header}>\n      <Toggle values={tabs} value={selectedTab} onChange={whenDefined(setSelectedTab)}/>\n    </div>\n    {render(selectedTab)}\n  </>\n}\n","import style from \"./App.module.styl\"\nimport Demo from \"./Demo\"\nimport Meta from \"./Meta\"\nimport Tabs from \"./Tabs\"\n\nconst tabs: { [key: string]: () => JSX.Element } = {\n  Demo,\n  Meta,\n}\n\nexport default function App() {\n  return <div className={style.app}>\n    <header className={style.header}>\n      Meta UI\n    </header>\n    <main className={style.main}>\n      <div className={style.page}>\n        <Tabs tabs={Object.keys(tabs)} render={tab => {\n          const Tab = tabs[tab]\n          return <Tab/>\n        }}/>\n      </div>\n    </main>\n  </div>\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport App from \"./app/App\"\nimport \"./index.styl\"\nimport reportWebVitals from \"./reportWebVitals\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}